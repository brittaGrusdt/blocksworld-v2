var log_likelihood_dirichlet = cache(function(table, stimulus){
  var par = filter(function(obj){
    return(obj.id == stimulus)
  }, globalStore.params_ll)[0]
  var alphas = [par["alpha_1"], par["alpha_2"], par["alpha_3"], par["alpha_4"]]
  var ll = Dirichlet({"alpha": Vector(alphas)}).score(Vector(table))
  return(ll)
})

// var TruncatedNormal = cache(function(ac){
//   Infer({method:'MCMC', samples:10000, model:function(){
//     var x = sample(gaussian({mu: ac, sigma: globalStore.sigma_indep}))
//     condition(x >= 0 && x <= 1)
//     return(Math.round(x*1000)/1000)
// }})
// }, 10000)

// var log_likelihood = function(state){
//   var p = cn_to_prob(state)
//   return state.cn == "A || C" ?
//     TruncatedNormal(p[0]).score(Math.round(p[1]*p[2]*100)/100)
//     // Gaussian({mu:p[0]*p[1], sigma: globalStore.indep_sigma}).score(p[2]) :
//     // all dependent cns
//     (Beta({a:10, b:1}).score(p[0]) + Beta({a:1, b:10}).score(p[1]))
// }

var state_prior = cache(function(bias) {
  var distr =
    Infer({method:'enumerate', model:function(){
      var TableID = uniformDraw(globalStore.Tables)
      var Table = TableID.Table
      var cn = uniformDraw(globalStore.cns);
      var state = {"table": Table,
                   "cn": cn,
                   "stimulus": TableID.stimulus,
                   "id": TableID.id};
     // display(TableID)
     let logl_table =
       state.cn=="A implies C" ? TableID.logL_if_ac :
       state.cn=="A implies -C" ? TableID.logL_if_anc :
       state.cn=="C implies A" ? TableID.logL_if_ca :
       state.cn=="C implies -A" ? TableID.logL_if_cna :
       state.cn=="A || C" ? TableID.logL_ind :
       error("unknown cn: " + state.cn);

      // some tables may have a 0 probability for certain causal nets, i.e.
      // these values are -Infinity (from R to here this becomes undefined)
      factor(logl_table ? logl_table : -Infinity);
      return {"bn": state}
    }});
  return(distr)
})
