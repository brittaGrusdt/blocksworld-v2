// There are 4 blocks, 3 à 5 trials and 1 à 3 trials
// the first three blocks contain each 2 a->c and 2 a ind. c and 1 a<->c
// they appear in any order constraint to: not two of the same kind in a row:
// (12 possibilities)
const TYPE_ORDERS = [
  ['z', 'x', 'y', 'x', 'y'],
  ['z', 'y', 'x', 'y', 'x'],

  ['y', 'z', 'x', 'y', 'x'],
  ['x', 'z', 'y', 'x', 'y'],

  ['x', 'y', 'z', 'x', 'y'],
  ['x', 'y', 'z', 'y', 'x'],
  ['y', 'x', 'z', 'y', 'x'],
  ['y', 'x', 'z', 'x', 'y'],

  ['x', 'y', 'x', 'z', 'y'],
  ['y', 'x', 'y', 'z', 'x'],

  ['x', 'y', 'x', 'y', 'z'],
  ['y', 'x', 'y', 'x', 'z']
];
const TYPE_MAP = {x: 'a_implies_c', y: 'independent', z: 'a_iff_c'}

// for each of the three blocks a different order is chosen again constraint to
// not two of the same kind in a row.
// the fourth block contains one of each type, again: the first one cant be the
// last one of the third block
let Dist = Infer({model: function(){
        let o1 = uniformDraw(TYPE_ORDERS).join('');
        let o2 = uniformDraw(TYPE_ORDERS).join('');
        condition(o1 !== o2 && _.last(o1) !== _.first(o2))
        let o3 = uniformDraw(TYPE_ORDERS).join('');
        condition(o3 !== o1 && o3 !== o2 && _.last(o2) !== _.first(o3));
        let l = _.last(o3)
        let o4 = _.shuffle(_.without(_.keys(TYPE_MAP), l)).join('') + l
        return o1 + o2 + o3 + o4
      }});
display(Dist.support().length)

let orders = Dist.support();

// Test
let xs = [];
let ys = [];
let zs = [];

var countTypes = function(val, arr){
  map(function(str){
    arr.push(sum(map(function(s){
      return s===val
    }, str.split(''))))
  }, orders)
}

countTypes('x', xs);
countTypes('y', ys);
countTypes('z', zs);
let x = all(function(val){return val===7}, xs);
let y = all(function(val){return val===7}, ys);
let z = all(function(val){return val===4}, zs);
display('x: ' + x + ' y: ' + y + ' z: ' + z)

json.write('trial_type_orders.json', orders);
// orders;
